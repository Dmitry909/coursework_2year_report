\documentclass[a4paper,12pt]{extarticle}
\usepackage{geometry}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{fancyhdr}
\usepackage{setspace}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{tikz}
\usepackage{pgf}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{indentfirst}
\usepackage[
backend=biber,
style=numeric,
maxbibnames=99
]{biblatex}
\addbibresource{refs.bib}
\usepackage[colorlinks,citecolor=blue,linkcolor=blue,bookmarks=false,hypertexnames=true, urlcolor=blue]{hyperref} 
\usepackage{indentfirst}
\usepackage{mathtools}
\usepackage{booktabs}
\usepackage[flushleft]{threeparttable}
\usepackage{tablefootnote}

\usepackage{chngcntr} % нумерация графиков и таблиц по секциям
\counterwithin{table}{section}
\counterwithin{figure}{section}

\graphicspath{{graphics/}}%путь к рисункам

\makeatletter
% \renewcommand{\@biblabel}[1]{#1.} % Заменяем библиографию с квадратных скобок на точку:
\makeatother

\geometry{left=2.5cm}% левое поле
\geometry{right=1.0cm}% правое поле
\geometry{top=2.0cm}% верхнее поле
\geometry{bottom=2.0cm}% нижнее поле
\setlength{\parindent}{1.25cm}
\renewcommand{\baselinestretch}{1.5} % междустрочный интервал


\newcommand{\bibref}[3]{\hyperlink{#1}{#2 (#3)}} % biblabel, authors, year
\addto\captionsrussian{\def\refname{Список литературы (или источников)}} 

\renewcommand{\theenumi}{\arabic{enumi}}% Меняем везде перечисления на цифра.цифра
\renewcommand{\labelenumi}{\arabic{enumi}}% Меняем везде перечисления на цифра.цифра
\renewcommand{\theenumii}{.\arabic{enumii}}% Меняем везде перечисления на цифра.цифра
\renewcommand{\labelenumii}{\arabic{enumi}.\arabic{enumii}.}% Меняем везде перечисления на цифра.цифра
\renewcommand{\theenumiii}{.\arabic{enumiii}}% Меняем везде перечисления на цифра.цифра
\renewcommand{\labelenumiii}{\arabic{enumi}.\arabic{enumii}.\arabic{enumiii}.}% Меняем везде перечисления на цифра.цифра

\begin{document}
\input{title.tex}% это титульный лист - выберите подходящий вам из имеющихся в проекте вариантов
\newpage
\setcounter{page}{2}

{
	\hypersetup{linkcolor=black}
	\tableofcontents
}

\newpage

\begin{sloppypar}

\newpage
\section{Аннотация}   % this is how to use russian
Курсовой проект представляет собой реализацию метода хэширования с учётом энтропии \cite{the_paper} \cite{the_paper_github} в СУБД ClickHouse. Пользователи СУБД используют хэширование для ускорения поиска данных, для проверок целостности данных, для распределения данных между серверами, поэтому его скорость важна для пользователей. Классические алгоритмы хэширования, хоть и хорошо оптимизированы по скорости работы, для этих оптимизаций никак не используют информацию, содержащуюся в самих хэшируемых данных. Однако, если мы знаем особенности данных, которые будут хэшироваться, то можем использовать эти знания для ускорения хэширования. 

Суть используемого мной метода состоит в том, что бы хэшировать не все строки, а только символы на определённых позициях в них обычной хэш-функцией. Функция обучается один раз на наборе строк, то есть выбирает номера позиций символов в строках, наиболее сильно их различающие. Далее эти выбранные позиции используются для хэширования уже других строк, вычисляя обычный хэш от их подпоследовательностей, состоящих из символов на ранее выбранных позициях. 

Оптимизация заключается в уменьшении размера хэшируемой строки. Например, для строк $aa, ab, ac$ при хэшировании имеет смысл использовать только второй символ, игнорируя первый, т.к. первый символ никак не различает строки. Другой пример: если мы имеем массив url-адресов, то первые 4 символа в них бесполезны для хэширования, поскольку они все равны $http$. 

% \addcontentsline{toc}{section}{Аннотация}

\section{Ключевые слова}
Базы данных, системы управления базами данных, СУБД, хэш-функции, хэширование с учётом энтропии, оптимизация хэширования, ускорение хэширования.
\pagebreak

% TODO Переименовать разделы по-нормальному, согласно именно моей теме!

\section{Введение}
\subsection{Описание предметной области}

В СУБД существуют функции хеширования, они позволяют пользователям проще и быстрее работать с данными. В рамках своего курсового проекта я реализовал метод хэширования с учётом энтропии в ClickHouse -- колоночной СУБД с открытым исходным кодом, написанной на языке C++.

\subsection{Постановка задачи}

Задача -- внедрить в ClickHouse функции, осуществляющие обучение модели на наборе строк и хэширующие, возможно, другой набор строк, используя данные, полученные в результате обучения. Первая функция за полиномиальное время определяет, какие позиции в строках-элементах данных предоставляют информации о данных больше других, а вторая -- используя посчитанные первой функцией номера позиций, выбирает только нужные символы из строк и передаёт их в хэш-функцию, которой может являться любая из существующих в СУБД.

\subsection{Актуальность и значимость}

К данному моменту разработано большое количество разнообразных хэш-функций, в том числе предназначенных для СУБД, то есть работающих быстрее других за счёт потери своих неважных для СУБД свойств. Классические хэш-функции для оптимизации своей работы никак не используют информацию, содержащуюся в самих данных, так как они разработаны для применения к любым данным. Однако, если мы хэшируем какие-то специфические данные, то мы можем ускорить хэширование за счёт знаний об устройстве этих данных. На практике в таблицах баз данных определённые столбцы хранят определённые типы данных. В ситуациях, когда у хэшируемых данных существуют определённые особенности, метод хэширования с учётом энтропии должен показать свою эффективность.

\subsection{Результаты}

В результате работы в ClickHouse реализованы и протестированы функции, осуществляющие хэширование с учётом энтропии. Тесты покрывают различные сценарии использования.

Также был проведён тест производительности, он показал целесообразность использования хэширования с учётом энтропии вместо обычных функций хэширования, когда строки имеют длину в несколько сотен символов и более.

\pagebreak

\section{Обзор похожих программных решений}

Статья с описанием метода \cite{the_paper} \cite{the_paper_github} была опубликована в 2022 году, до этого подобных методов известно не было. В статье указана информация о тестировании метода, проверялось его использование в различных приложениях хэширования, таких как хэш-таблицы, фильтры Блума и задачи секционирования. Поскольку метод показал эффективность у авторов статьи, возникло желание реализовать его в ClickHouse.

\newpage

\section{Описание и обоснование выбранных архитектурных решений}
\subsection{Описание метода}
Чтобы познакомиться с методом, я прочитал статью \cite{the_paper} \cite{the_paper_github}, из которой узнал о том, как работает метод. Как я уже указал в аннотации, суть метода состоит в том, чтобы хэшировать не сами строки, а лишь некоторые их подпоследовательности символов. Для любого конечного набора попарно различных строк существует конечное множество позиций в них наименьшей мощности, задающее, какие подпоследовательности строк выбирать так, чтобы эти подпоследовательности тоже оказались попарно различными. Как утверждают авторы статьи, задача нахождения такого наименьшего по мощности множества позиций NP-трудна, однако существует полиномиальный алгоритм, находящий $1-\frac{1}{e}$ приближение размера множества позиций и само это множество. 

Перед описанием алгоритма введём некоторые определения:

\begin{itemize}
	\item Энтропия мультимножества строк -- сумма квадратов размеров групп одинаковых строк мультимножества. Например, энтропия мультимножества $\{ab, ae, ab\}$ равна $4^2+1^2 = 5$.
	\item Подпоследовательность строки по множеству позиций -- строка, состоящая только из тех символов строки, номера которых содержатся в множестве позиций, в том порядке, в котором они идут в оригинальной строке. Например, если множество равно $\{0, 2\}$, тогда из строки $abcd$ будет составлена строка $ac$.
	\item Будем говорить, что множество позиций различает строки, если при выборке подпоследовательностей из них получаются попарно различные строки.
	\item Назовём главной хэш-функций ту, которая применяется к выбранным подпоследовательностям строк. Она должна быть одной из уже существующих в проекте \cite{clickhouse_hash_functions}.
\end{itemize}

Алгоритм таков: дан массив строк, требуется найти описанное множество позиций. На протяжении работы алгоритма поддерживается это множество, изначально оно пусто. Пока множество не различает строки, будем выбирать одну новую позицию, которая максимально увеличит энтропию среди всех ещё не выбранных позиций и добавлять её в множество. Алгоритм конечен, т.к. конечны длины строк, а позиций набрать можно не больше, чем длина самой длинной строки.

После выбора позиций они будут использованы при одном или нескольких вызовах функции хэширования с учётом энтропии, которая выбирает из строк подпоследовательности по этим позициям и возвращает хэши, полученные применением главной хэш-функции к ним.  

\subsection{Реализация прототипа метода}

Сначала мной был реализован прототип метода хэширования с учётом энтропии, он содержит функцию: \texttt{ChooseBytes}, которая принимает массив строк и выбирает множество позиций для них описанным выше алгоритмом. Этот прототип был проверен и одобрен руководителем, и стал основной для реализации метода в коде ClickHouse.

\subsection{Требования к функциональности реализуемых в проекте функций}

Сначала я покажу функциональность вызовов SQL-функций. Перед этим нужно создать таблицы \texttt{tbl\_train} и \texttt{table\_test} с единственным столбцом строк \texttt{x}:

\begin{itemize}
	\item \texttt{CREATE TABLE tbl\_train (x String) ENGINE = Memory} \newline \texttt{CREATE TABLE tbl\_test (x String) ENGINE = Memory}
\end{itemize}

А также теперь вставить в эти таблицы данные. Далее вызываем сами функции, моя реализация поддерживает следующие варианты вызовов:

\begin{itemize}
	\item \texttt{SELECT trainEntropyLearnedHash(column, 'dataset\_id') FROM tbl\_train} -- обучить метод (найти позиции) на всех строках столбца \texttt{column} таблицы \texttt{tbl\_train} и сохранить результат обучения по идентификатору \texttt{dataset\_id}.

	\item \texttt{SELECT entropyLearnedHash(column, 'dataset\_id') FROM tbl\_test} -- посчитать хэши с учётом энтропии от всех строк столбца \texttt{column} таблицы \texttt{tbl\_test}, используя позиции, полученные ранее в результате вызова функции \texttt{trainEntropyLearnedHash} с этим же идентификатором.

	\item \texttt{SELECT entropyLearnedHash(column, 'dataset\_id', 'farmHash64') FROM tbl\_test} -- то же, что предыдущее, но с заданием главной хэш-функции. Если этот параметр не задан, используется \texttt{cityHash64}. 
	
	\item \texttt{SELECT entropyLearnedHash(column, trainEntropyLearnedHash(column)) FROM tbl} -- передача результата обучения по цепочке, в этом случае столбец \texttt{column} берётся из одной и той же таблицы. Здесь вызов \texttt{trainEntropyLearnedHash(column)} должен возвращать
\end{itemize}

\subsection{Интеграция прототипа в код проекта}

Для интеграции прототипа в код проекта я склонировал репозиторий ClickHouse на свой компьютер, скомпилировал проект по инструкции \cite{clickhouse_build_instruction} и попробовал создавать таблицы и вызывать функции. Чтобы реализовать требуемые функции, я изучил устройство архитектуры проекта \cite{clickhouse_architecture}, в том числе используемые типы данных \cite{clickhouse_data_types}, а также правила реализации функций \cite{clickhouse_reqular_functions} \cite{clickhouse_aggregate_functions} и примеры реализаций других хэш-функций. 
Итак, для того, чтобы метод хэширования с учётом энтропии был доступен как SQL-функуция из клиентской части СУБД, должен быть реализован класс, наследующийся от интерфейса \texttt{IFunction}, содержащий такие методы, как получение название функции (\texttt{getName}), получение типа возвращаемого значения (\texttt{getReturnTypeImpl}), собственно сама реализация (\texttt{executeImpl}), а также некоторые другие. От этого класса впоследствии создаётся функция, принимающая в качестве шаблонного параметра этот класс.

Основной метод \texttt{executeImpl} должен принимать массив аргументов, где каждый аргумент является столбцом. Например, \texttt{ColumnString} означает столбец строк. Константы тоже задаются столбцами фактического размера 1, для этого есть специальный тип \texttt{ColumnConst}. Соответственно, \texttt{trainEntropyLearnedHash} может принимать либо только один столбец строк, либо столбец строк и строк идентификатора. Аналогично, \texttt{entropyLearnedHash} принимает от 2 до 3 аргументов, как это показано в предыдущем подразделе.

Для работы \texttt{trainEntropyLearnedHash} я реализовал также 3 вспомогательные внутренние функции на C++ и 1 класс: 
\begin{itemize}
	\item \texttt{allPartialKeysAreUnique} -- проверяет, различает ли набор позиций набор строк.
	\item \texttt{nextByte} -- находит, какую позицию добавить в множество, чтобы максимально уменьшить энтропию.
	\item \texttt{chooseBytes} -- исполняет вышеописанный алгоритм обучения, то есть находит двойное приближение позиций, различающих строки.
	\item класс \texttt{IdManager} -- реализуется с помощью паттерна singleton (одиночка) и хранит в себе словарь результатов обучения (массивов позиций) по идентификатрам.
\end{itemize}

\texttt{trainEntropyLearnedHash} использует эти функции, а сама производит преобразования над данными, требуемые архитектурой. В итоге функция возвращает строку из нулей и единиц, где позиции единиц задают выбранные позиции. Если в функцию был передан идентификатор, она сохраняет результат обучения по этому идентификатору в \texttt{IdManager}.

Функция \texttt{entropyLearnedHash} принимает, как я уже написал выше, от 2 до 3 аргументов, по ним понимает, какой набор позиций нужно использовать и какая главная хэш-функция должна использоваться, и применяет к выбранным по позициям подпоследовательностям строк главную хэш-функцию.

Проверки валидности аргументов функций проверяются автоматически, используя правила, заданные в методах \texttt{getReturnTypeImpl}. Например, для функции \texttt{entropyLearnedHash} этот метод делает проверку того, что переданные аргументы -- столбцы строк (в том числе, возможно, состоящие из 1 элемента), и их от 2 до 3.

\newpage

\section{Тестирование разработанного решения}
\subsection{Тестирование работоспособности и корректности}
Чтобы узнать, как происходит тестирование в ClickHouse, я прочитал документацию по тестированию \cite{clickhouse_testing}. Из неё я узнал, что для тестирования работоспособности и корректности написанного кода используются функциональные тесты, имитирующие возможные сценарии использования функций пользователями, то есть представляющие собой набор последовательных SQL-команд для взаимодействия с БД. Я изучил инструкцию по написанию функциональных тестов \cite{clickhouse_sql_test_queries}, постепенно добавляя новые возможности в код, писал на них тесты. Мои тесты охватывают проверку корректности работы функций, когда:

\begin{itemize}
	\item строки различимы только лишь выбором всех символов,
	\item строки различимы выбором лишь части символов,
	\item строки различимы выбором лишь части символов при различных длинах строк,
	\item используются разные функции хэширования выбранных байт,
	\item результат обучения передаётся по цепочке.
\end{itemize}

\subsection{Тестирование производительности}

Также я сравнил время работы метода хэширования с учётом энтропии и функции \texttt{cityHash64} (являющейся главной в методе, если не задана другая) на наборах данных разных размеров, от $10^6$ до $10^7$, состоящих из синтетических строк разных длин от $100$ до $800$. Для этого я создал bash-скрипт, выполяющий создание таблицы, генерацию данных, обучение (то есть вызов \texttt{trainEntropyLearnedHash}) на выборке, состоящей из $1\%$ случайных строк из сгенерированных данных и, собственно, вызовов \texttt{entropyLearnedHash} и \texttt{cityHash64} на сгенерированных данных. Последние 2 вызова происходят с использованием утилиты \texttt{clickhouse-benchmark} которая может исполнять SQL-команду несколько раз независимо и измерять её время выполнения. Я настроил запуск десять раз, а потом сам выбирал медианное значение времени из десяти получившихся.

Результаты теста представлены в таблице ниже. Каждая пара соседних строк внутри талицы обозначает время выполнения \texttt{entropyLearnedHash} и \texttt{cityHash64} соответственно. Числа слева от строк таблицы обозначают длину одной строки во всём столбце данных, а числа над столбцами обозначают размеры наборов данных.

\begin{table}[]
\begin{tabular}{lllll}
	& \multicolumn{2}{l}{1000000} & \multicolumn{2}{l}{10000000} \\ \cline{2-5} 
\multicolumn{1}{l|}{100} & \multicolumn{1}{l|}{0.071} & \multicolumn{1}{l|}{0.062} & \multicolumn{1}{l|}{0.722} & \multicolumn{1}{l|}{0.431} \\ \cline{2-5} 
\multicolumn{1}{l|}{300} & \multicolumn{1}{l|}{0.074} & \multicolumn{1}{l|}{0.095} & \multicolumn{1}{l|}{0.658} & \multicolumn{1}{l|}{0.704} \\ \cline{2-5} 
\multicolumn{1}{l|}{500} & \multicolumn{1}{l|}{0.087} & \multicolumn{1}{l|}{0.116} & \multicolumn{1}{l|}{0.605} & \multicolumn{1}{l|}{0.941} \\ \cline{2-5} 
\multicolumn{1}{l|}{800} & \multicolumn{1}{l|}{0.078} & \multicolumn{1}{l|}{0.189} & \multicolumn{1}{l|}{0.63} & \multicolumn{1}{l|}{1.752} \\ \cline{2-5} 
\end{tabular}
\end{table}

Из результатов теста видно, что при увеличении длин строк метод хэширования с учётом энтропии работает примерно столько же по времени, в том время время выполнения обычной функции увеличивается пропорционально длинам строк.

\newpage

\section{Заключение}
\subsection{Результаты работы}
В результате выполнения курсовой работы в коде ClickHouse реализован метод хэширования с учётом энтропии на языке C++ с соблюдением норм стиля кода проекта \cite{clickhouse_code_style_guide}. Работа пользователя с ним осуществляется при помощи двух функций: \texttt{trainEntropyLearnedHash}, которая находит оптимальный с точностью до двух раз набор символов, которые достаточно выбирать из строк для того, чтобы их различать, и функции \texttt{entropyLearnedHash}, которая осуществляет выборку из строк столбца нужных (выбранных первой функцией) символов и применяет к ним заданную функцию хэширования.

Корректность и работоспособность реализованных функций проверена написанными функциональными тестами, имитирующими работу с функциями реальных пользователей. Они рассматривают несколько различных случаев данных и покрывают все возможные сценарии использования.

Из проведённого теста производительности можно сделать вывод, что метод применим, он действительно улучшает производительность. Его точно можно использовать, когда пользователю не важны некоторые свойства хэш-функций. 

\subsection{Перспективы дальнейшей деятельности}

Сейчас метод показывает себя лучше обычного хэширования лишь на строках длиной примерно от 300 символов. Нужно лучше соптимизировать код, чтобы эффектиность достигалась и на меньших по длине строках.

\newpage

\section{Список литературы}
% \printbibliography[heading=bibintoc]
\printbibliography[heading=none]
\newpage

\end{sloppypar}

% \section{Приложения (удалить, если не надо)}

% \subsection{Ссылки на статьи}

% Ссылки на статьи оформляются с помощью пакета \texttt{biblatex}, например~\cite{chirkova18}. В описании статье в bib файле нужно обязательно указывать место публикации работы (журнал или конференцию) и год. Обратите внимание, что для описания статей из разных источников в списке литературы используются разные команды в bib файле: статья из журнала~\cite{ctan}, статья с конференции~\cite{chirkova18}, книга~\cite{knuth-acp}, глава книги~\cite{knuth-fa}. Если статься еще не опубликована нигде, а только выложена на arXiv, то на нее тоже можно сослаться~\cite{chirkova18_arxiv}, но предпочтительно ссылаться на опубликованную версию, если она уже существует. Если вы хотите сослаться на сайт, то можно либо так же внести его в список литературы~\cite{knuthwebsite} (рекомендуется, если таких ссылок у вас много из-за особенностей темы вашего проекта), либо использовать ссылку внизу страницы\footnote{Книги доступны по ссылке: \url{http://www-cs-faculty.stanford.edu/~uno/abcde.html}, дата обр. 16.05.2013}. При работе с онлайн ресурсами не забывайте указывать дату обращения к этому ресурсу, так как в отличие от опубликованных статей, эти ресурсы могут измениться в любой момент.

% \cite{clickhouse_architecture}
% \cite{clickhouse_build_instruction}
% \cite{clickhouse_reqular_functions}
% \cite{clickhouse_aggregate_functions}
% \cite{clickhouse_data_types}
% \cite{clickhouse_reqular_functions}
% \cite{clickhouse_aggregate_functions}
% \cite{clickhouse_hash_functions}
% \cite{clickhouse_hash_functions}
% \cite{clickhouse_code_style_guide}
% \cite{clickhouse_testing}
% \cite{clickhouse_sql_test_queries}
% \cite{the_paper}

% \subsection{Рисунки}

% \begin{figure}[ht]
% 	\centering
% 	\includegraphics[width=0.8\textwidth]{example.png}
% 	\caption{Пример графика. Тут должна быть подпись, поясняющая что происходит на рисунке (краткая, но достаточная для понимания основной идеи графика).}
% 	\label{fig:by_epochs}
% \end{figure}

% Все рисунки в тексте должны иметь подписи и вы на них должны ссылаться в тексте. Например, на Рисунке~\ref{fig:by_epochs} изображен пример графика. Не забывайте подписывать все оси на графиках, добавлять легенду и пояснять все обозначения, а также используйте адекватного размера шрифты и толщину линий на графиках (все должно быть видно и понятно без многократного увеличения). На рисунке из примера явно не хватает обозначения синей линии в легенде.


% \subsection{Таблицы}

% Все таблицы в тексте тоже должны иметь подписи и вы на них должны ссылаться в тексте. Например, в Таблице~\ref{table:long_epochs} показаны результаты примерного эксперимента. 


% \begin{table}[ht]
% 	\caption{Пример таблички. Тут должна быть подпись, поясняющая что происходит в таблице (краткая, но по делу).}
% 	\label{table:long_epochs}
% 	\footnotesize
% 	\centering
% 	\begin{tabular}{lrrrrrrrr}
% 		\toprule
% 		& \multicolumn{3}{c}{$\mathsf{Val}$} &
% 		\multicolumn{3}{c}{$\mathsf{Test}$} \\
% 		\cmidrule(lr){2-4} \cmidrule(l){5-7} 
% 		{} &  $\mathsf{Prec}$ &  $\mathsf{Rec}$ &  $\mathsf{F1}$ &  $\mathsf{Prec}$ &  $\mathsf{Rec}$ &  $\mathsf{F1}$  &  $\mathsf{nodes}$ & $\mathsf{subtokens}$\\
% 		\midrule
% 		запуск 1    &    0.4894 &   0.3775 &  0.4263 &     0.4824 &    0.3683 &   0.4177 & 10029 & 179\\
% 		запуск 2    &    0.4887 &   0.3739 &  0.4237 &     0.4891 &    0.3724 &   0.4228 & 10039 & 177\\
% 		запуск 3    &    0.4820 &   0.3751 &  0.4219 &     0.4838 &    0.3677 &   0.4178 & 10037&	180\\
% 		\midrule
% 		\bf{среднее} &    \bf{0.4867} &   \bf{0.3755} &  \bf{0.4239} &    \bf{ 0.4851} &    \bf{0.3695} &   \bf{0.4195} \\
% 		\bf{дисперсия}  &    0.0041 &   0.0019 &  0.0022 &     0.0036 &    0.0025 &   0.0029 \\
% 		\bottomrule
% 	\end{tabular}
% \end{table}

% \subsection{Формулы}

% Формулы стоит центрировать, а также нумеровать, если вы ссылаете на них в тексте. Также не забывайте пояснять все обозначения в формулах. Например, запишем следующую задачу оптимизации:
% \begin{equation}
%     \label{eq:si_opt}
%         \theta* = \min_{\theta} F(\theta),
% \end{equation}
% где $F$~-- квадратичная функция от параметра $\theta$. При необходимости, далее в тексте можно сослаться на формулу~(\ref{eq:si_opt}). При этом, в зависимости от конкретных формул, можно использовать разные слова: формула, уравнение, задача оптимизации и т.п.


% \begin{thebibliography}{0}
% 	\bibitem{chirkova18}\hypertarget{chirkova18}{}
% 	\href{https://arxiv.org/abs/1810.10927}
% 	{Nadezhda Chirkova, Ekaterina Lobacheva, Dmitry Vetrov. Bayesian Compression for Natural Language Processing. In EMNLP 2018.}
% \end{thebibliography}
	
	
\end{document}
